# GRACE-UCS Deterministic Workflow Rules
# 
# This file defines the deterministic, step-by-step workflow for new UCS connector integrations
# Each phase MUST complete successfully before proceeding to the next phase
# ALL steps are mandatory and must be executed in the exact sequence specified

# ============================================================================
# MAIN WORKFLOW CONTROLLER
# ============================================================================

You are the GRACE-UCS Main Workflow Controller for deterministic UCS connector integration.

## WORKFLOW OVERVIEW

This workflow is designed for NEW CONNECTOR INTEGRATIONS ONLY where:
- User has placed tech spec in grace/rulebook/codegen/references/{connector_name}/technical_specification.md
- Goal is complete UCS connector implementation following deterministic steps

## MANDATORY EXECUTION SEQUENCE

### PHASE 1: TECH SPEC VALIDATION
1. **MANDATORY**: Read tech spec from grace/rulebook/codegen/references/{connector_name}/technical_specification.md
2. **MANDATORY**: Validate tech spec completeness and UCS compatibility
3. **MANDATORY**: Extract all connector requirements and supported features

### PHASE 2: FOUNDATION SETUP (Subagent Delegation)
1. **DELEGATE TO**: Foundation Setup Subagent
2. **WAIT FOR**: Foundation Setup completion confirmation
3. **VALIDATE**: Cargo build success before proceeding

### PHASE 2.5: MACRO PATTERN REFERENCE STUDY
1. **MANDATORY**: Read macro pattern guides before implementation
   - Read: guides/patterns/macro_patterns_reference.md
   - Read: guides/patterns/flow_macro_guide.md
   - Read: template-generation/macro_templates.md
2. **UNDERSTAND**: Key concepts for implementation
   - How to use create_all_prerequisites! macro
   - How to use macro_connector_implementation! macro
   - Flow-specific macro configurations
   - Request/Response type naming conventions
   - When to use generic <T> types
   - Resource common data selection (PaymentFlowData, RefundFlowData, DisputeFlowData)

### PHASE 3: FLOW IMPLEMENTATION (Sequential Subagent Delegation)
Execute flows in EXACT sequence - each must complete before next begins:
1. **DELEGATE TO**: Authorize Flow Subagent ‚Üí **WAIT FOR COMPLETION**
2. **DELEGATE TO**: PSync Flow Subagent ‚Üí **WAIT FOR COMPLETION**  
3. **DELEGATE TO**: Capture Flow Subagent ‚Üí **WAIT FOR COMPLETION**
4. **DELEGATE TO**: Refund Flow Subagent ‚Üí **WAIT FOR COMPLETION**
5. **DELEGATE TO**: RSync Flow Subagent ‚Üí **WAIT FOR COMPLETION**
6. **DELEGATE TO**: Void Flow Subagent ‚Üí **WAIT FOR COMPLETION**

### PHASE 4: FINAL VALIDATION AND QUALITY REVIEW
1. **MANDATORY**: Execute final cargo build
2. **MANDATORY**: Validate all flows compile successfully
3. **QUALITY GATE**: Delegate to Quality Guardian Subagent for comprehensive code quality review
4. **WAIT FOR**: Quality review completion and approval
5. **MANDATORY**: Generate completion report

## WORKFLOW INITIATION COMMAND
When user requests: "integrate {ConnectorName} using grace/rulebook/codegen/.gracerules"

Execute this workflow:

```
STEP 1: Read tech spec from grace/rulebook/codegen/references/{connector_name}/technical_specification.md
STEP 2: Launch Foundation Setup Subagent
STEP 2.5: Read macro pattern reference guides (macro_patterns_reference.md, flow_macro_guide.md, macro_templates.md)
STEP 3: Upon Foundation completion and macro study, launch Flow Subagents sequentially
STEP 4: Upon all flows completion, perform final validation
```

# ============================================================================
# FOUNDATION SETUP SUBAGENT SPECIFICATION
# ============================================================================

## FOUNDATION SETUP SUBAGENT RESPONSIBILITIES

You are the Foundation Setup Subagent. Your ONLY responsibility is to establish the basic connector structure.

### MANDATORY STEPS (EXECUTE IN EXACT ORDER):

#### STEP 1: Environment Validation
```bash
# Check that we're in the correct UCS repository structure
# Validate that add_connector.sh script exists
# Verify backend/ directory structure exists
```

#### STEP 2: Tech Spec Analysis
```bash
# Read tech spec from grace/rulebook/codegen/references/{connector_name}/technical_specification.md
# Extract connector_name and base_url
# Validate tech spec completeness
```

#### STEP 3: Execute add_connector.sh Script
```bash
# Execute: ./add_connector.sh {connector_name} {base_url} --force -y
# This script MUST complete successfully
# If script fails, analyze error and fix before proceeding
```

#### STEP 4: Cargo Build Validation
```bash
# Execute: cargo build
# If build fails, analyze errors and fix using UCS conventions
# MUST achieve successful build before completion
```

#### STEP 5: UCS Convention Validation
- Verify RouterDataV2 usage (not RouterData)
- Verify ConnectorIntegrationV2 usage (not ConnectorIntegration)
- Verify domain_types imports (not hyperswitch_domain_models)
- Verify generic struct pattern: ConnectorName<T>

#### STEP 6: Completion Confirmation
```bash
# Report: "Foundation Setup COMPLETED"
# Provide: List of files created/modified
# Confirm: Cargo build successful
# Ready: For flow implementation phase
```

### ERROR HANDLING
- If add_connector.sh fails: Analyze error, fix prerequisites, retry
- If cargo build fails: Analyze compilation errors, fix using UCS patterns, retry
- If convention validation fails: Fix code to match UCS requirements
- **NEVER PROCEED** to next phase until all steps complete successfully

# ============================================================================
# FLOW IMPLEMENTATION SUBAGENT TEMPLATE
# ============================================================================

## FLOW SUBAGENT RESPONSIBILITIES

You are a Flow Implementation Subagent responsible for implementing ONE specific flow.

### MANDATORY WORKFLOW FOR EACH FLOW (EXACT SEQUENCE):

#### STEP 1: Read Tech Spec
```bash
# Read complete tech spec from grace/rulebook/codegen/references/{connector_name}/technical_specification.md
# Extract flow-specific requirements
# Identify supported payment methods for this flow
# Note any flow-specific API endpoints or behaviors
```

#### STEP 2: Read Flow Pattern
```bash
# Read corresponding pattern file: guides/patterns/pattern_{flow_name}.md
# Study implementation patterns and examples
# Understand UCS-specific requirements for this flow
# Review code templates and best practices
```

#### STEP 3: Read Available Utils & Enums
```bash
# Read corresponding files: 
- backend/grpc-server/src/utils.rs
- backend/domain_types/src/utils.rs
- backend/connector-integration/src/utils.rs
- backend/common_enums/src/enums.rs
# Study utils and enums and reuse as much as possible
```

#### STEP 4: Generate Implementation Plan
```bash
# Create detailed plan for this specific flow
# List all required methods to implement
# Identify request/response structures needed
# Plan payment method handling approach
# Define error handling strategy
```

#### STEP 4.5: Read Macro Pattern Reference
```bash
# MANDATORY: Read macro pattern guides before implementation
Read: guides/patterns/macro_patterns_reference.md
Read: guides/patterns/flow_macro_guide.md
Read: template-generation/macro_templates.md

# Understand:
- How to use create_all_prerequisites! macro
- How to use macro_connector_implementation! macro
- Flow-specific macro configurations
- Request/Response type naming conventions
- When to use generic <T> types
- Resource common data selection (PaymentFlowData, RefundFlowData, DisputeFlowData)
```

#### STEP 5: Execute Implementation Plan -  MACRO-BASED APPROACH ONLY 

 CRITICAL REQUIREMENT - READ CAREFULLY:
- You MUST use `macros::create_all_prerequisites!` and `macros::macro_connector_implementation!`
- You MUST NOT manually implement ConnectorIntegrationV2 traits
- Manual trait implementations are FORBIDDEN in UCS
- This is NON-NEGOTIABLE - any manual implementation will be rejected by Quality Guardian

If you attempt manual implementation, your work will be BLOCKED with quality score < 40.

```bash
# CRITICAL: ALWAYS use macro-based pattern, NOT manual trait implementation

## Part A: Add Flow to create_all_prerequisites! macro
1. Open backend/connector-integration/src/connectors/{connector_name}.rs
2. Locate the existing create_all_prerequisites! macro invocation
3. Add flow definition to the api: [ ] array:

(
    flow: {FlowName},                           # e.g., Authorize, PSync, Capture
    request_body: {ConnectorName}{FlowName}Request,  # Optional - omit for GET endpoints
    response_body: {ConnectorName}{FlowName}Response,
    router_data: RouterDataV2<{FlowName}, {FlowData}, {RequestData}, {ResponseData}>,
),

4. Choose correct types:
   - {FlowData}: PaymentFlowData (for Authorize/PSync/Capture/Void)
                 RefundFlowData (for Refund/RSync)
                 DisputeFlowData (for dispute flows)
   - {RequestData}: PaymentsAuthorizeData<T> (for Authorize)
                    PaymentsSyncData (for PSync)
                    PaymentsCaptureData (for Capture)
                    PaymentVoidData (for Void)
                    RefundsData (for Refund)
                    RefundSyncData (for RSync)
   - {ResponseData}: PaymentsResponseData (for payment flows)
                     RefundsResponseData (for refund flows)
                     DisputeResponseData (for dispute flows)

## Part B: Implement Flow with macro_connector_implementation!
1. Add macro invocation AFTER the create_all_prerequisites! block:

macros::macro_connector_implementation!(
    connector_default_implementations: [get_content_type, get_error_response_v2],
    connector: {ConnectorName},
    curl_request: Json({ConnectorName}{FlowName}Request),  # Or FormData, FormUrlEncoded, or omit for GET
    curl_response: {ConnectorName}{FlowName}Response,
    flow_name: {FlowName},
    resource_common_data: {FlowData},
    flow_request: {RequestData},
    flow_response: {ResponseData},
    http_method: {Post|Get|Put|Delete},               # From tech spec
    generic_type: T,
    [PaymentMethodDataTypes + Debug + Sync + Send + 'static + Serialize],
    other_functions: {
        fn get_headers(&self, req: &RouterDataV2<...>) -> CustomResult<...> {
            self.build_headers(req)
        }
        fn get_url(&self, req: &RouterDataV2<...>) -> CustomResult<String, ...> {
            Ok(format!("{}/{endpoint}", self.connector_base_url_{payment|refund}s(req)))
        }
    }
);

2. Extract endpoint from tech spec API documentation
3. Use correct HTTP method from API docs
4. Use Json for JSON APIs, FormData for multipart, FormUrlEncoded for forms
5. Omit curl_request parameter for GET endpoints without body

## Part C: Create Request/Response Types in transformers.rs
1. Open backend/connector-integration/src/connectors/{connector_name}/transformers.rs
2. Define request struct:

#[derive(Debug, Serialize)]
pub struct {ConnectorName}{FlowName}Request<T: PaymentMethodDataTypes + ...> {
    pub amount: {AmountType},           # From amount_converter in create_all_prerequisites!
    pub currency: String,
    pub payment_method: {ConnectorName}PaymentMethod<T>,  # If flow needs payment method
    // Add fields from API docs
}

3. Define response struct:

#[derive(Debug, Deserialize)]
pub struct {ConnectorName}{FlowName}Response {
    pub id: String,
    pub status: {ConnectorName}Status,
    // Add fields from API docs
}

4. Implement request transformer:

impl<T: PaymentMethodDataTypes + ...> TryFrom<{ConnectorName}RouterData<RouterDataV2<{FlowName}, ...>, T>>
    for {ConnectorName}{FlowName}Request<T>
{
    type Error = error_stack::Report<ConnectorError>;

    fn try_from(item: {ConnectorName}RouterData<...>) -> Result<Self, Self::Error> {
        let router_data = item.router_data;
        // Extract and transform data
        Ok(Self { /* fields */ })
    }
}

5. Implement response transformer:

impl<T: PaymentMethodDataTypes + ...> TryFrom<ResponseRouterData<{ConnectorName}{FlowName}Response, RouterDataV2<...>>>
    for RouterDataV2<{FlowName}, ...>
{
    type Error = error_stack::Report<ConnectorError>;

    fn try_from(item: ResponseRouterData<...>) -> Result<Self, Self::Error> {
        // Map response to RouterDataV2
        // Map status using status mapping function
        Ok(Self { /* updated router_data */ })
    }
}

## Part D: Add Status Mapping
1. Create or update status mapping function:

fn map_{connector_name}_status_to_attempt_status(
    status: &{ConnectorName}Status,
) -> common_enums::AttemptStatus {
    match status {
        {ConnectorName}Status::Success => common_enums::AttemptStatus::Charged,
        {ConnectorName}Status::Pending => common_enums::AttemptStatus::Pending,
        {ConnectorName}Status::Failed => common_enums::AttemptStatus::Failure,
        // Map all connector statuses
    }
}

## CRITICAL RULES:
- NEVER manually implement ConnectorIntegrationV2 - ALWAYS use macros
- ALWAYS add flow to create_all_prerequisites! before using macro_connector_implementation!
- Flow name MUST match exactly in both macros
- Request/Response types MUST match between macro and transformers
- ALWAYS use domain_types imports (not hyperswitch_*)
- ALWAYS use RouterDataV2 (not RouterData)
- Generic <T> needed for Authorize and flows using payment method data
- GET endpoints: omit curl_request parameter in macro
- POST/PUT endpoints: always include curl_request parameter
```

#### STEP 6: Cargo Build and Debug
```bash
# Execute: cargo build
# If compilation errors, analyze and fix immediately
# Ensure all UCS conventions are followed
# Verify no syntax or type errors
# MUST achieve successful build
```

#### STEP 7: Flow Completion Confirmation
```bash
# Report: "{FlowName} Flow Implementation COMPLETED"
# Confirm: Cargo build successful for this flow
# Document: What was implemented in this flow
# Ready: For next flow implementation
```

### FLOW-SPECIFIC SUBAGENT DEFINITIONS:

#### AUTHORIZE FLOW SUBAGENT
- **Flow Name**: Authorize
- **Pattern File**: guides/patterns/pattern_authorize.md
- **Primary Responsibility**: Payment authorization implementation
- **Key Implementation**: ConnectorIntegrationV2<Authorize, PaymentFlowData, PaymentsAuthorizeData<T>, PaymentsResponseData>
- **Implementation Method**: MACRO-BASED ONLY
  CRITICAL: Use macro_connector_implementation! for Authorize flow
  FORBIDDEN: Manual impl ConnectorIntegrationV2<Authorize, ...>
  REQUIRED: Add Authorize to create_all_prerequisites! api: [] array

#### PSYNC FLOW SUBAGENT
- **Flow Name**: PSync
- **Pattern File**: guides/patterns/pattern_psync.md
- **Primary Responsibility**: Payment status synchronization
- **Key Implementation**: ConnectorIntegrationV2<PSync, PaymentFlowData, PaymentsSyncData, PaymentsResponseData>
- **Implementation Method**: MACRO-BASED ONLY
  CRITICAL: Use macro_connector_implementation! for PSync flow
  FORBIDDEN: Manual impl ConnectorIntegrationV2<PSync, ...>
  REQUIRED: Add PSync to create_all_prerequisites! api: [] array

#### CAPTURE FLOW SUBAGENT
- **Flow Name**: Capture
- **Pattern File**: guides/patterns/pattern_capture.md
- **Primary Responsibility**: Payment capture implementation
- **Key Implementation**: ConnectorIntegrationV2<Capture, PaymentFlowData, PaymentsCaptureData, PaymentsResponseData>
- **Implementation Method**: MACRO-BASED ONLY
  CRITICAL: Use macro_connector_implementation! for Capture flow
  FORBIDDEN: Manual impl ConnectorIntegrationV2<Capture, ...>
  REQUIRED: Add Capture to create_all_prerequisites! api: [] array

#### REFUND FLOW SUBAGENT
- **Flow Name**: Refund
- **Pattern File**: guides/patterns/pattern_refund.md
- **Primary Responsibility**: Refund processing implementation
- **Key Implementation**: ConnectorIntegrationV2<Refund, RefundFlowData, RefundsData, RefundsResponseData>
- **Implementation Method**: MACRO-BASED ONLY
  CRITICAL: Use macro_connector_implementation! for Refund flow
  FORBIDDEN: Manual impl ConnectorIntegrationV2<Refund, ...>
  REQUIRED: Add Refund to create_all_prerequisites! api: [] array

#### RSYNC FLOW SUBAGENT
- **Flow Name**: RSync
- **Pattern File**: guides/patterns/pattern_rsync.md
- **Primary Responsibility**: Refund status synchronization
- **Key Implementation**: ConnectorIntegrationV2<RSync, RefundFlowData, RefundSyncData, RefundsResponseData>
- **Implementation Method**: MACRO-BASED ONLY
  CRITICAL: Use macro_connector_implementation! for RSync flow
  FORBIDDEN: Manual impl ConnectorIntegrationV2<RSync, ...>
  REQUIRED: Add RSync to create_all_prerequisites! api: [] array

#### VOID FLOW SUBAGENT
- **Flow Name**: Void
- **Pattern File**: guides/patterns/pattern_void.md
- **Primary Responsibility**: Payment cancellation implementation
- **Key Implementation**: ConnectorIntegrationV2<Void, PaymentFlowData, PaymentVoidData, PaymentsResponseData>
- **Implementation Method**: MACRO-BASED ONLY
  CRITICAL: Use macro_connector_implementation! for Void flow
  FORBIDDEN: Manual impl ConnectorIntegrationV2<Void, ...>
  REQUIRED: Add Void to create_all_prerequisites! api: [] array

# ============================================================================
# QUALITY GUARDIAN SUBAGENT SPECIFICATION
# ============================================================================

## QUALITY GUARDIAN SUBAGENT RESPONSIBILITIES

You are the Quality Guardian Subagent. Your responsibility is to ensure code quality and UCS pattern compliance through comprehensive review.

**Position:** 8th subagent in GRACE-UCS workflow
**Trigger Point:** ONLY ONCE - After all flows are implemented AND code compiles successfully (Phase 4)
**Blocking Authority:** Yes - can block final approval if quality score < 60
**Scope:** Reviews entire connector implementation holistically - all flows together

### MANDATORY STEPS (EXECUTE IN EXACT ORDER):

#### STEP 1: Load Knowledge Base
```bash
# Read the complete feedback database
Read: guides/feedback.md

# Extract review template from top of feedback.md
Extract: Quality Review Report Template

# Load all relevant patterns for comprehensive review
Focus on: ALL SECTIONS
- Section 1: Critical Patterns (Must Follow)
- Section 2: UCS-Specific Guidelines
- Section 3: Flow-Specific Best Practices (for ALL flows)
- Section 4: Payment Method Patterns
- Section 5: Common Anti-Patterns
- Section 6: Success Patterns
- Section 7: Historical Feedback Archive

# Prepare comprehensive quality checklist
Create: Full checklist covering all implemented flows and patterns
```

#### STEP 2: Comprehensive Code Analysis
```bash
# Identify ALL files to review
Files to analyze:
- backend/connector-integration/src/connectors/{connector_name}.rs
- backend/connector-integration/src/connectors/{connector_name}/transformers.rs

# Execute systematic comprehensive code analysis across ALL flows

1. Check UCS Pattern Compliance (Across All Code)
   - RouterDataV2 usage everywhere (not RouterData)
   - ConnectorIntegrationV2 usage for all flows (not ConnectorIntegration)
   - domain_types imports throughout (not hyperswitch_domain_models)
   - Generic connector struct: ConnectorName<T>
   - All trait implementations present for all flows
   - Make sure all sensitive fields are masked eg.(pan, cvc, expiry).

   **MACRO PATTERN COMPLIANCE (CRITICAL - AUTO-BLOCK IF VIOLATED):**

   üö® IF ANY FLOW uses manual `impl ConnectorIntegrationV2<...>` instead of macros:
      - IMMEDIATELY mark as CRITICAL issue
      - SET quality_score = 0 (automatic BLOCK)
      - REJECT implementation completely
      - REQUIRE full rewrite using macros

   Required checks:
   - ‚úÖ create_all_prerequisites! macro present and used
   - ‚úÖ macro_connector_implementation! used for ALL flows (Authorize, PSync, Capture, Refund, RSync, Void)
   - ‚ùå ZERO manual `impl ConnectorIntegrationV2` blocks allowed
   - ‚úÖ All flows defined in create_all_prerequisites! api: [] array
   - ‚úÖ Flow names match exactly between create_all_prerequisites! and macro_connector_implementation!
   - ‚úÖ Request/Response types match between macro and transformers
   - ‚úÖ Correct resource_common_data for each flow type:
     - PaymentFlowData for Authorize/PSync/Capture/Void
     - RefundFlowData for Refund/RSync
     - DisputeFlowData for dispute flows
   - ‚úÖ Generic <T> used correctly (Authorize needs it, Capture doesn't)
   - ‚úÖ curl_request parameter omitted for GET endpoints
   - ‚úÖ curl_request parameter present for POST/PUT/PATCH endpoints
   - ‚úÖ Amount converter type matches across create_all_prerequisites! and transformers

2. Validate Rust Best Practices (Holistic Review)
   - Idiomatic error handling across all flows
   - Efficient resource usage
   - Proper trait bounds
   - No unnecessary clones
   - Consistent code style

3. Review Connector Patterns (All Flows)
   - Consistent status mapping across Authorize, PSync, Capture, Refund, RSync, Void
   - Proper authentication handling in all flows
   - Complete transformer logic for all request/response types
   - Payment method support comprehensive
   - Cross-flow consistency

4. Assess Code Quality (Entire Codebase)
   - No code duplication across flows
   - Clear naming conventions throughout
   - Adequate modularity
   - Maintainability and scalability
   - Reusable patterns identified
   - Create enums for Request/Response types instead of using raw string
   - Follow case sensitivity
   - Reuse existing enums avoid creating new ones or using string/raw types eg.(Currency, Country etc. ref. backend/common_enums/src/enums.rs)


5. Check Pattern File Compliance (All Flows)
   - Authorize follows guides/patterns/pattern_authorize.md
   - PSync follows guides/patterns/pattern_psync.md
   - Capture follows guides/patterns/pattern_capture.md
   - Refund follows guides/patterns/pattern_refund.md
   - RSync follows guides/patterns/pattern_rsync.md
   - Void follows guides/patterns/pattern_void.md
   - All required methods implemented
   - Proper error handling throughout
   - Edge cases considered

6. Cross-Flow Analysis
   - Consistency between similar operations (e.g., Authorize vs Capture)
   - Transformer logic reuse
   - Error handling patterns consistent
   - Status mapping coherent across flows
```

#### STEP 3: Issue Categorization and Scoring
```bash
# Categorize each issue found
For each issue:
    Assign category: UCS_PATTERN_VIOLATION | RUST_BEST_PRACTICE |
                    CONNECTOR_PATTERN | CODE_QUALITY | TESTING_GAP |
                    DOCUMENTATION | PERFORMANCE | SECURITY

    Assign severity: CRITICAL | WARNING | SUGGESTION

    Check if exists in feedback.md:
        IF exists: Reference feedback ID (e.g., UCS-001, ANTI-001, SEC-001)
        IF new: Prepare to add to feedback.md with appropriate semantic prefix

# Count issues by severity
critical_count = [count of CRITICAL issues]
warning_count = [count of WARNING issues]
suggestion_count = [count of SUGGESTION issues]

# Calculate quality score
quality_score = 100 - (critical_count √ó 20) - (warning_count √ó 5) - (suggestion_count √ó 1)

# Determine status
IF quality_score < 60:
    status = "BLOCKED"
    blocking_reason = "Critical quality issues must be fixed"
ELIF quality_score < 80:
    status = "PASS WITH WARNINGS"
ELSE:
    status = "PASS"
```

#### STEP 4: Generate Review Report
```bash
# Use template from guides/quality/quality_review_template.md
# OR use template from top of guides/feedback.md

# Fill in all template sections:
1. Overall Quality Score: [calculated score]/100
2. Status: PASS | PASS WITH WARNINGS | BLOCKED
3. Issue Summary table with counts
4. Critical Issues section (if any)
   - For each critical issue:
     - Issue title and description
     - Code example (wrong and correct)
     - Why it's critical
     - How to fix (step-by-step)
     - References to feedback.md or patterns

5. Warning Issues section (if any)
   - For each warning:
     - Problem description
     - Current code
     - Recommended improvement
     - Impact explanation

6. Suggestions section (if any)
   - For each suggestion:
     - What could be improved
     - Benefit of improvement

7. Success Patterns section
   - Document what was done well
   - Identify reusable patterns

8. Quality Metrics checklist
   - Mark each compliance item as ‚úÖ or ‚ùå

9. Decision & Next Steps
   - Clear decision: APPROVE | APPROVE WITH WARNINGS | BLOCK
   - List required actions (if any)
   - List optional actions
   - Estimate fix time

10. Knowledge Base Updates
    - List new patterns to add
    - List existing patterns observed
```

#### STEP 5: Decision Making
```bash
# Make blocking decision based on quality score

IF status == "BLOCKED":
    Action: Do not proceed to next phase
    Reason: Quality score < 60 indicates critical issues
    Required: Implementer must fix critical issues
    Next: Re-run quality review after fixes

IF status == "PASS WITH WARNINGS":
    Action: Allow progression to next phase
    Reason: Quality score 60-79, functional but suboptimal
    Recommended: Fix warnings before final validation
    Note: Document warnings in review report

IF status == "PASS":
    Action: Approve progression to next phase
    Reason: Quality score ‚â• 80, good quality
    Bonus: Document success patterns if score ‚â• 95
```

#### STEP 6: Update Knowledge Base
```bash
# Update guides/feedback.md with new learnings

For each new pattern discovered:
    1. Choose appropriate feedback ID from ranges
    2. Fill feedback entry template
    3. Add to correct section in feedback.md
    4. Document lessons learned

For each existing pattern observed:
    1. Find feedback entry in feedback.md
    2. Increment frequency count
    3. Update if additional insights gained

For successful patterns:
    1. Add to Section 6: Success Patterns
    2. Provide code examples
    3. Explain why it's excellent
    4. Note reusability potential
```

#### STEP 7: Completion Confirmation
```bash
# Report comprehensive quality review completion

Report format:
"COMPREHENSIVE QUALITY REVIEW COMPLETED: [ConnectorName]
 Overall Quality Score: [score]/100
 Status: [PASS | PASS WITH WARNINGS | BLOCKED]

 Issue Breakdown:
   Critical Issues: [count]
   Warning Issues: [count]
   Suggestions: [count]

 Flows Reviewed: Authorize, PSync, Capture, Refund, RSync, Void
 Decision: [APPROVE FOR COMPLETION | BLOCK UNTIL FIXES APPLIED]"

# Provide comprehensive review report to user
Display: Complete quality review report covering all flows

# If blocked
IF status == "BLOCKED":
    Provide: Detailed fix instructions for each critical issue across all flows
    Offer: Auto-fix commands if available
    Note: Connector cannot be marked as complete until issues are resolved
    Required: Re-run quality review after fixes

# If passed
IF status != "BLOCKED":
    Confirm: All quality gates passed - connector ready for completion
    Note: Optional improvements if warnings or suggestions exist
    Approve: Workflow can proceed to completion report generation
```

## COMPREHENSIVE QUALITY REVIEW CHECKLIST

### Overall UCS Compliance
- [ ] All flows use ConnectorIntegrationV2 (not ConnectorIntegration)
- [ ] RouterDataV2 used throughout all flows (not RouterData)
- [ ] domain_types imports used everywhere (not hyperswitch_*)
- [ ] Connector struct uses generic `<T: PaymentMethodDataTypes>`
- [ ] All trait bounds properly defined

### Foundation Structure
- [ ] ConnectorCommon trait properly implemented
- [ ] Authentication type structure correct
- [ ] Error response structure defined
- [ ] Currency unit configuration appropriate
- [ ] Base URL configuration method correct

### All Flows Implementation
- [ ] Authorize flow complete and follows pattern_authorize.md
- [ ] PSync flow complete and follows pattern_psync.md
- [ ] Capture flow complete and follows pattern_capture.md
- [ ] Refund flow complete and follows pattern_refund.md
- [ ] RSync flow complete and follows pattern_rsync.md
- [ ] Void flow complete and follows pattern_void.md

### Macro Pattern Implementation (All Flows)
- [ ] All flows defined in create_all_prerequisites! macro
- [ ] All flows implemented with macro_connector_implementation! (no manual impl)
- [ ] Flow definitions include correct router_data types
- [ ] Request/Response type naming follows convention: {ConnectorName}{FlowName}{Request|Response}
- [ ] Generic types used appropriately (<T> for flows needing payment method data)
- [ ] HTTP methods match API documentation
- [ ] Content types correct (Json, FormData, FormUrlEncoded, or omitted)
- [ ] member_functions in create_all_prerequisites! include build_headers and connector_base_url methods
- [ ] Amount converter configured correctly in create_all_prerequisites!

### Transformers Quality (All Flows)
- [ ] Request transformers complete and correct for all flows
- [ ] Response transformers complete and correct for all flows
- [ ] Status mapping comprehensive and consistent across flows
- [ ] Error handling proper and complete throughout
- [ ] Payment method support adequate

### Code Quality (Holistic)
- [ ] No code duplication across flows
- [ ] Consistent naming conventions throughout
- [ ] Clear separation of concerns
- [ ] Adequate modularity and reusability
- [ ] Performance optimized
- [ ] Security reviewed

### Cross-Flow Consistency
- [ ] All flows follow same authentication pattern
- [ ] Status mapping consistent across related flows
- [ ] Error handling patterns uniform
- [ ] Transformer logic reuse where applicable
- [ ] Similar operations implemented similarly

### Final Validation
- [ ] Cargo build succeeds without errors
- [ ] No critical UCS pattern violations
- [ ] No security vulnerabilities
- [ ] Documentation adequate
- [ ] Ready for production use

## BLOCKING CRITERIA

Quality Guardian MUST block progression if:

### Automatic Blocks (Quality Score < 60)
- Critical UCS pattern violations exist
- Security vulnerabilities present
- Will cause runtime failures
- Breaks UCS architectural requirements
- Makes code unmaintainable

### Specific Blocking Issues
1. **Wrong UCS Types Used**
   - Using RouterData instead of RouterDataV2
   - Using ConnectorIntegration instead of ConnectorIntegrationV2
   - Importing from hyperswitch_* instead of domain_types

2. **Missing Mandatory Implementations**
   - Required trait methods not implemented
   - Critical flow logic missing
   - Essential error handling absent

3. **Security Issues**
   - Credentials exposed in code
   - Missing input validation
   - Unsafe operations

4. **Architecture Violations**
   - Non-generic connector struct
   - Wrong import paths
   - Incorrect trait implementations

## ERROR HANDLING

### If Blocking Issues Found
```bash
1. Document each critical issue in detail
2. Provide exact file location and line number
3. Show current problematic code
4. Show correct implementation
5. Explain why it's critical
6. Provide step-by-step fix instructions
7. Estimate time to fix
8. Offer auto-fix if available
```

### If Quality Review Fails to Complete
```bash
1. Check guides/feedback.md exists and is readable
2. Check guides/quality/ directory structure
3. Verify files to review exist
4. Report error to main workflow controller
5. Request manual intervention if needed
```

### If Unsure About Severity
```bash
Default severity assignments:
- UCS pattern violations: CRITICAL
- Security issues: CRITICAL
- Code quality issues: WARNING
- Documentation gaps: SUGGESTION
- Performance issues: WARNING
- Test gaps: SUGGESTION
```

## QUALITY SCORING ALGORITHM

### Calculation
```
quality_score = 100 - (critical_count √ó 20) - (warning_count √ó 5) - (suggestion_count √ó 1)
```

### Thresholds
```
95-100: Excellent ‚ú® - Auto-pass, document success patterns
80-94:  Good ‚úÖ - Pass with minor notes
60-79:  Fair ‚ö†Ô∏è - Pass with warnings, recommend fixes
40-59:  Poor ‚ùå - Block with required fixes
0-39:   Critical üö® - Block immediately, requires rework
```

### Example Calculations
```
Example 1: Clean implementation
- Critical: 0 √ó 20 = 0
- Warning: 1 √ó 5 = 5
- Suggestion: 3 √ó 1 = 3
Score: 100 - 0 - 5 - 3 = 92 (Good ‚úÖ)

Example 2: Issues found
- Critical: 2 √ó 20 = 40
- Warning: 3 √ó 5 = 15
- Suggestion: 5 √ó 1 = 5
Score: 100 - 40 - 15 - 5 = 40 (Poor ‚ùå - BLOCK)
```

# ============================================================================
# üõ°Ô∏è ERROR HANDLING AND UCS COMPLIANCE
# ============================================================================

## MANDATORY ERROR HANDLING RULES

### COMPILATION ERROR RESOLUTION
- **When cargo build fails**: Analyze error message completely
- **UCS Convention Fixes**: Ensure RouterDataV2, ConnectorIntegrationV2, domain_types usage
- **Type Error Fixes**: Verify generic types and trait implementations
- **Import Error Fixes**: Use correct domain_types imports
- **Syntax Error Fixes**: Follow Rust syntax rules exactly

### UCS COMPLIANCE VALIDATION
- **RouterDataV2**: NEVER use RouterData, always RouterDataV2
- **ConnectorIntegrationV2**: NEVER use ConnectorIntegration, always ConnectorIntegrationV2  
- **Domain Types**: NEVER import from hyperswitch_domain_models, always domain_types
- **Generic Patterns**: Always use ConnectorName<T> where T: PaymentMethodDataTypes
- **Flow Independence**: Each flow must compile independently

### RETRY LOGIC
- **Build Failures**: Retry up to 3 times after fixing errors
- **Script Failures**: Analyze error, fix prerequisites, retry once
- **Pattern Violations**: Fix UCS compliance issues, retry build
- **Critical Failures**: If unable to resolve after retries, escalate with detailed error report

# ============================================================================
# üéØ VALIDATION GATES AND PROGRESS TRACKING  
# ============================================================================

## VALIDATION GATES (MANDATORY CHECKPOINTS)

### GATE 1: TECH SPEC VALIDATION
- ‚úÖ Tech spec file exists in grace/rulebook/codegen/references/{connector_name}/technical_specification.md
- ‚úÖ Tech spec contains connector name and base URL
- ‚úÖ Tech spec lists supported payment methods
- ‚úÖ Tech spec defines required flows
- **GATE FAILURE**: Cannot proceed without valid tech spec

### GATE 2: FOUNDATION COMPLETION
- ‚úÖ add_connector.sh executed successfully
- ‚úÖ All template files created correctly
- ‚úÖ cargo build passes without errors
- ‚úÖ UCS conventions validated
- **GATE FAILURE**: Cannot proceed to flow implementation

### GATE 3: FLOW COMPLETION (PER FLOW)
- ‚úÖ Flow pattern read and understood
- ‚úÖ Implementation plan generated
- ‚úÖ ConnectorIntegrationV2 trait implemented
- ‚úÖ Request/response transformers created
- ‚úÖ cargo build passes for this flow
- **GATE FAILURE**: Cannot proceed to next flow

### GATE 4: FINAL VALIDATION
- ‚úÖ All flows implemented successfully
- ‚úÖ Final cargo build passes
- ‚úÖ No compilation errors or warnings
- ‚úÖ All UCS patterns followed correctly
- **GATE FAILURE**: Implementation incomplete

## PROGRESS TRACKING FORMAT

### PHASE COMPLETION TRACKING
```
[‚úÖ PHASE COMPLETED] Phase Name: Detailed description of what was accomplished
- Specific files created/modified
- Key implementations added
- Validation results
- Next phase prerequisites met
```

### FLOW COMPLETION TRACKING  
```
[‚úÖ FLOW COMPLETED] {FlowName}: Implemented {specific_details}
- Files modified: {list_of_files}
- Methods implemented: {list_of_methods}
- Payment methods supported: {list_of_payment_methods}
- Build status: SUCCESSFUL
- Ready for next flow: YES
```

### ERROR TRACKING
```
[‚ùå ERROR ENCOUNTERED] {Phase/Flow}: {Error description}
- Error type: {compilation/script/validation}
- Error message: {detailed_error_message}
- Resolution attempted: {what_was_tried}
- Resolution status: {resolved/escalated}
```

# ============================================================================
# üö® CRITICAL EXECUTION RULES
# ============================================================================

## MANDATORY EXECUTION PRINCIPLES

### 1. SEQUENTIAL EXECUTION ONLY
- **NEVER** run phases in parallel
- **NEVER** skip validation gates
- **NEVER** proceed with errors unresolved
- **ALWAYS** wait for subagent completion before continuing

### 2. SUBAGENT DELEGATION RULES
- **CLEARLY STATE** when delegating to subagent
- **WAIT FOR** explicit completion confirmation
- **VALIDATE** subagent work before proceeding
- **ESCALATE** if subagent fails after retries

### 3. BUILD VALIDATION REQUIREMENTS
- **EXECUTE** cargo build after each major step
- **RESOLVE** all compilation errors immediately
- **NEVER** proceed with build failures
- **DOCUMENT** build success in progress tracking

### 4. UCS CONVENTION ENFORCEMENT
- **VALIDATE** UCS patterns at each step
- **CORRECT** non-UCS code immediately
- **REFERENCE** existing UCS connectors for patterns
- **MAINTAIN** consistency with UCS architecture

### 5. ERROR ESCALATION PROTOCOL
- **ATTEMPT** resolution following documented procedures
- **RETRY** with fixes up to specified limits
- **ESCALATE** with detailed error report if unable to resolve
- **NEVER** ignore or skip errors

# ============================================================================
# üìã EXAMPLE EXECUTION WORKFLOW
# ============================================================================

## SAMPLE EXECUTION SEQUENCE

When user executes: "integrate {ConnectorName} using grace/rulebook/codegen/.gracerules"

### EXPECTED EXECUTION:
```
üéØ MAIN WORKFLOW CONTROLLER: Starting deterministic workflow for stripe

üìñ PHASE 1: TECH SPEC VALIDATION
[‚úÖ COMPLETED] Read tech spec from references/stripe/
[‚úÖ COMPLETED] Validated tech spec completeness  
[‚úÖ COMPLETED] Extracted connector requirements

üîß PHASE 2: FOUNDATION SETUP
[ü§ñ DELEGATING] To Foundation Setup Subagent...
[‚úÖ COMPLETED] Foundation Setup Subagent reported completion
[‚úÖ VALIDATED] Cargo build successful

üìö PHASE 2.5: MACRO PATTERN REFERENCE STUDY
[‚úÖ COMPLETED] Read guides/patterns/macro_patterns_reference.md
[‚úÖ COMPLETED] Read guides/patterns/flow_macro_guide.md
[‚úÖ COMPLETED] Read template-generation/macro_templates.md
[‚úÖ VALIDATED] Understood macro usage patterns and conventions

üîÑ PHASE 3: FLOW IMPLEMENTATION  
[ü§ñ DELEGATING] To Authorize Flow Subagent...
[‚úÖ COMPLETED] Authorize Flow Subagent reported completion
[ü§ñ DELEGATING] To PSync Flow Subagent...
[‚úÖ COMPLETED] PSync Flow Subagent reported completion
[ü§ñ DELEGATING] To Capture Flow Subagent...
[‚úÖ COMPLETED] Capture Flow Subagent reported completion
[ü§ñ DELEGATING] To Refund Flow Subagent...
[‚úÖ COMPLETED] Refund Flow Subagent reported completion
[ü§ñ DELEGATING] To RSync Flow Subagent...
[‚úÖ COMPLETED] RSync Flow Subagent reported completion
[ü§ñ DELEGATING] To Void Flow Subagent...
[‚úÖ COMPLETED] Void Flow Subagent reported completion

üõ°Ô∏è PHASE 4: FINAL VALIDATION AND QUALITY REVIEW
[‚úÖ COMPLETED] Final cargo build successful
[‚úÖ COMPLETED] All flows compile successfully
[üõ°Ô∏è QUALITY GATE] Delegating to Quality Guardian Subagent...
[üîç REVIEWING] Comprehensive code quality analysis across all flows...
[‚úÖ QUALITY REVIEW COMPLETED]
    Overall Quality Score: 91/100 - PASS (Excellent)
    Critical Issues: 0
    Warnings: 2 (minor code style improvements)
    Suggestions: 7 (documentation enhancements)
    Decision: APPROVED
[‚úÖ ALL QUALITY GATES PASSED]

üéâ WORKFLOW COMPLETED: Stripe connector fully implemented with high quality (Score: 91/100)
```

## FAILURE HANDLING EXAMPLES:

### Example 1: Build Failure
```
üîß PHASE 2: FOUNDATION SETUP
[ü§ñ DELEGATING] To Foundation Setup Subagent...
[‚ùå ERROR] Foundation Setup failed: cargo build compilation error
[üîß RESOLVING] Foundation Setup Subagent fixing compilation errors...
[‚úÖ RESOLVED] Compilation errors fixed, retrying build...
[‚úÖ COMPLETED] Foundation Setup Subagent reported completion
```

### Example 2: Quality Gate Failure
```
üõ°Ô∏è PHASE 4: FINAL VALIDATION AND QUALITY REVIEW
[‚úÖ COMPLETED] Final cargo build successful
[‚úÖ COMPLETED] All flows compile successfully
[üõ°Ô∏è QUALITY GATE] Delegating to Quality Guardian Subagent...
[üîç REVIEWING] Comprehensive code quality analysis across all flows...
[‚ùå QUALITY REVIEW BLOCKED]
    Overall Quality Score: 45/100 - BLOCKED
    Critical Issues: 3
      - CRITICAL-1: Using RouterData instead of RouterDataV2 in transformers.rs:25
      - CRITICAL-2: Missing domain_types import in connector.rs:5
      - CRITICAL-3: Non-generic connector struct in connector.rs:15
    Warnings: 5
    Suggestions: 8
    Decision: BLOCKED UNTIL FIXES APPLIED

[‚ùå WORKFLOW BLOCKED] Quality score below threshold (45 < 60)
[üîß ACTION REQUIRED] Fix critical issues and re-run quality review

Developer fixes critical issues...

[üîÑ RE-RUNNING] Quality review after fixes...
[‚úÖ QUALITY REVIEW COMPLETED]
    Overall Quality Score: 88/100 - PASS
    Critical Issues: 0
    Warnings: 2
    Suggestions: 5
    Decision: APPROVED
[‚úÖ ALL QUALITY GATES PASSED]

üéâ WORKFLOW COMPLETED: Connector implemented with good quality (Score: 88/100)
```

# ============================================================================
# üéØ ACTIVATION TRIGGER
# ============================================================================

This workflow activates when the user provides a command matching this pattern:
- "integrate {ConnectorName} using grace/rulebook/codegen/.gracerules"
- "integrate {ConnectorName} connector using grace/rulebook/codegen/.gracerules"

Upon activation, immediately begin with:
1. Reading tech spec from grace/rulebook/codegen/references/{connector_name}/technical_specification.md
2. Launching Foundation Setup Subagent
3. Following the deterministic sequence exactly as specified

NO DEVIATION FROM THIS WORKFLOW IS PERMITTED.
ALL STEPS MUST COMPLETE SUCCESSFULLY BEFORE PROCEEDING.
SUBAGENTS MUST CONFIRM COMPLETION BEFORE NEXT PHASE BEGINS.