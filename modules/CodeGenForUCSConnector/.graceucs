# UCS Connector Service Agent - GRACE-UCS

# Connector Integration for UCS (Universal Connector Service)

GRACE-UCS is an AI-assisted system for comprehensive UCS connector development supporting RESUMABLE development from ANY implementation state.

üéØ CORE CAPABILITIES:
- NEW IMPLEMENTATIONS: Complete connector development from scratch
- RESUME PARTIAL WORK: Continue from where developers stopped
- ADD FEATURES: Extend existing connectors with new payment methods/flows
- DEBUG & FIX: Diagnose and resolve issues in existing implementations
- ALL PAYMENT METHODS: Cards, wallets, bank transfers, BNPL, crypto, regional methods
- COMPLETE FLOW COVERAGE: Authorize, capture, void, refund, sync, webhooks, 3DS, mandates

üèóÔ∏è UCS ARCHITECTURE REQUIREMENTS [CRITICAL]:
- ALWAYS use RouterDataV2 (NOT RouterData) - from domain_types::router_data_v2::RouterDataV2
- ALWAYS use ConnectorIntegrationV2 (NOT ConnectorIntegration) - from interfaces::connector_integration_v2::ConnectorIntegrationV2
- ALWAYS import from domain_types (NOT hyperswitch_domain_models)
- Use macros::create_all_prerequisites! macro for flow implementations
- Use connector trait implementations like connector_types::PaymentAuthorizeV2, PaymentSyncV2, etc.
- gRPC-first communication (Protocol Buffers)
- Stateless design (no database dependencies in connector logic)
- Generic connector struct with PaymentMethodDataTypes: Connector<T> where T: PaymentMethodDataTypes

üìã USAGE SCENARIOS:

NEW CONNECTOR:
Command: "integrate [ConnectorName] using grace-ucs/.gracerules"
Process: 
1. Use add_connector.sh to generate boilerplate
2. Follow tech_spec.md ‚Üí planner_steps.md ‚Üí implementation
3. Implement actual logic in transformers and main files

RESUME PARTIAL:
Command: "continue implementing [ConnectorName] connector in UCS - I have [existing_features] and need [missing_features]"
Process: assess current state ‚Üí plan remaining work ‚Üí implement

ADD FEATURES:
Command: "add [payment_methods/flows] to existing [ConnectorName] connector in UCS"
Process: analyze existing code ‚Üí plan additions ‚Üí implement features

DEBUG/FIX:
Command: "fix [ConnectorName] connector [issue_description] in UCS"
Process: diagnose issue ‚Üí plan fix ‚Üí implement solution

TEMPLATE GENERATION:
Command: "./connector_template/add_connector.sh [connector_name] [base_url]"
Purpose: Generates complete boilerplate code structure with all required files and registrations
Note: AI MUST check if template files already exist before running script

[MUST READ ALL FILES FIRST BEFORE ANY IMPLEMENTATION]

üìÅ STRUCTURE:
grace-ucs/
‚îú‚îÄ‚îÄ guides/
‚îÇ   ‚îú‚îÄ‚îÄ connector_integration_guide.md - COMPREHENSIVE UCS integration process [MUST FOLLOW]
‚îÇ   ‚îú‚îÄ‚îÄ patterns/pattern_authorize.md - UCS-specific implementation patterns [ESSENTIAL]
‚îÇ   ‚îú‚îÄ‚îÄ types/types.md - Complete UCS type system guide [CRITICAL]
‚îÇ   ‚îú‚îÄ‚îÄ errors/errors.md - UCS error handling and debugging [ESSENTIAL]
‚îÇ   ‚îú‚îÄ‚îÄ learnings/learnings.md - Lessons from UCS implementations [IMPORTANT]
‚îÇ   ‚îî‚îÄ‚îÄ integrations/integrations.md - Previous UCS integration knowledge [REFERENCE]
‚îú‚îÄ‚îÄ connector_integration/
‚îÇ   ‚îî‚îÄ‚îÄ template/
‚îÇ       ‚îú‚îÄ‚îÄ tech_spec.md - UCS technical specification template [USE FOR PLANNING]
‚îÇ       ‚îî‚îÄ‚îÄ planner_steps.md - UCS implementation planning template [USE FOR EXECUTION]
‚îî‚îÄ‚îÄ references/{{connector_name}}/ - Connector-specific API documentation

üíé IMPLEMENTATION PRINCIPLES:

1. STATE ASSESSMENT FIRST:
   - ALWAYS check if connector template files already exist:
     * backend/connector-integration/src/connectors/[name].rs
     * backend/connector-integration/src/connectors/[name]/transformers.rs
   - If templates exist: skip template generation, analyze existing implementation
   - If templates missing: use ./connector_template/add_connector.sh FIRST
   - For partial implementations: analyze existing code, identify completed/missing features
   - For new implementations: check templates ‚Üí generate if needed ‚Üí follow tech specification
   - For debugging: understand the issue context and current behavior

2. COMPREHENSIVE PAYMENT METHOD SUPPORT:
   - Cards: All networks (Visa, MC, Amex, Discover, etc.)
   - Wallets: Apple Pay, Google Pay, PayPal, regional wallets
   - Bank Transfers: ACH, SEPA, local bank methods
   - BNPL: Klarna, Affirm, Afterpay, regional providers
   - Bank Redirects: iDEAL, Giropay, Sofort, etc.
   - Cash/Vouchers: Boleto, OXXO, convenience stores
   - Crypto: Bitcoin, Ethereum (if supported)
   - Regional: UPI, Alipay, WeChat Pay, etc.

3. COMPLETE FLOW COVERAGE (EACH FLOW INDEPENDENT):
   - Core: Authorize, Capture, Void, Refund, PSync, RSync
   - Advanced: CreateOrder, CreateSessionToken, SetupMandate
   - Webhooks: IncomingWebhook trait implementation
   - Disputes: DefendDispute, SubmitEvidence (if supported)
   - **CRITICAL: Each flow implemented independently with no cross-flow dependencies**

4. UCS-SPECIFIC PATTERNS:
   - Main file: backend/connector-integration/src/connectors/{{connector_name}}.rs
   - Transformers: backend/connector-integration/src/connectors/{{connector_name}}/transformers.rs
   - Add connector to: backend/connector-integration/src/connectors.rs (pub mod and pub use)
   - Generic struct pattern: pub struct ConnectorName<T> with PhantomData<T>
   - Trait implementations for each flow using connector_types traits
   - Use macros::create_all_prerequisites! for boilerplate flow implementations
   - **FOCUS ONLY ON IMPLEMENTATION CODE**: Do NOT create or implement test files
   - **TESTING IS SEPARATE**: Test files are handled by developers/QA team, not AI

5. MODULAR IMPLEMENTATION:
   - Each payment method as separate module
   - **EACH FLOW COMPLETELY INDEPENDENT** - no dependencies between flows
   - Each flow can be implemented, tested, and deployed separately
   - Authorize flow independent of Capture flow
   - Capture flow independent of Void flow
   - Refund flow independent of all payment flows
   - Sync flows independent of transaction flows
   - Proper error handling for each component
   - Comprehensive testing for each feature

6. RESUMABLE DEVELOPMENT:
   - Clear progress tracking and state documentation
   - **UPDATE planner steps with completion status and implementation details**
   - Modular code organization for easy continuation
   - Comprehensive comments for implementation context
   - Test coverage for regression prevention
   - **Mark each completed step with: [‚úÖ COMPLETED] + detailed description of what was implemented**

üîÑ PROCESS WORKFLOW:

ASSESSMENT PHASE:
1. Read ALL grace-ucs guide files
2. CHECK if connector template files exist (skip generation if present)
3. **STUDY existing UCS connectors for reference patterns (adyen.rs, razorpayv2.rs, checkout.rs)**
4. Analyze current implementation state (if resuming)
5. Review connector API documentation
6. Identify implementation priorities

PLANNING PHASE:
1. IF templates missing: generate using ./connector_template/add_connector.sh
2. Use tech_spec.md template for technical specification
3. Use planner_steps.md template for implementation planning
4. Create detailed step-by-step plan
5. Define success criteria and testing strategy

IMPLEMENTATION PHASE:
1. Follow UCS patterns from pattern_authorize.md
2. Use types from types.md
3. **WHEN STUCK: Study existing connector patterns, understand WHY they work that way**
4. **FOCUS ON IMPLEMENTATION CODE ONLY** - do NOT create test files
5. Implement in modular chunks (main connector file + transformers)
6. Verify compilation and basic functionality
7. **ASK FOR FEEDBACK** after each flow implementation (optional for user)
8. **STORE FEEDBACK** in learnings for future improvement
9. **MARK COMPLETED STEPS** in planner with implementation details
10. Update documentation during implementation

VALIDATION PHASE:
1. **CODE COMPILATION**: Verify code compiles with cargo check
2. **PATTERN COMPLIANCE**: Ensure UCS patterns are followed correctly
3. **DOCUMENTATION**: Complete implementation documentation
4. **NOTE**: Testing is handled separately by developers/QA team

üß™ TECH SPEC CREDIBILITY VALIDATION [CRITICAL - NEW MANDATORY PHASE]:

This phase runs AFTER tech spec generation, BEFORE implementation planning.

PURPOSE: Validate tech spec accuracy by testing against real connector API using curl commands.

CORE PRINCIPLE: **EVERYTHING for the curl comes from tech spec EXCEPT credentials (api_key, api_secret, key1)**

WORKFLOW:

1. **EXTRACT VALIDATION INFO FROM TECH SPEC** (YAML or Prose):

   **PREFERRED: Tech Spec with YAML Sections**
   When generating tech spec, STRONGLY RECOMMEND including structured YAML:
   - ‚úÖ api_config section: test_url, api_version, rate_limit
   - ‚úÖ auth section: header formats with {api_key} placeholders
   - ‚úÖ Complete flow specifications for all 6 flows (authorize, capture, void, refund, psync, rsync)
   - ‚úÖ Each flow with: method, path, request.test_example, response fields, status_mappings

   **FALLBACK: Extract from Prose if No YAML**
   If tech spec is pure Markdown prose, extract validation info by reading carefully:

   ‚úÖ **Base URL Extraction**:
      Look for: "API endpoint", "base URL", "sandbox", "test environment"
      Example: "Stripe's test API is at https://api.stripe.com"
      ‚Üí Extract: test_url = "https://api.stripe.com"

   ‚úÖ **Authentication Format Extraction**:
      Look for: "authorization", "authentication", "API key", "bearer token"
      Example: "Pass API key in Authorization header: `Authorization: Bearer sk_test_xxxxx`"
      ‚Üí Extract: auth_format = "Authorization: Bearer {api_key}"

   ‚úÖ **Endpoint & Method Extraction**:
      Look for: "POST to", "GET from", "send request to", "endpoint"
      Example: "To authorize, POST to /v1/payment_intents"
      ‚Üí Extract: method = "POST", path = "/v1/payment_intents"

   ‚úÖ **Request Body Extraction**:
      Look for: "required fields", "parameters", "request body", "must include"
      Example: "Required: amount (integer in cents), currency (ISO code)"
      ‚Üí Build test_example: {"amount": 1000, "currency": "USD"}

      For content-type, look for: "JSON", "form-encoded", "XML"
      Example: "Send JSON payload" ‚Üí content_type = "application/json"

   ‚úÖ **Response Structure Extraction**:
      Look for: "response contains", "returns", "includes fields"
      Example: "Response has 'id' field and 'status' field"
      ‚Üí Extract: id_field = "id", status_field = "status"

   ‚úÖ **Status Mapping Extraction**:
      Look for: status descriptions, "when status is", "means"
      Example: "'requires_capture' status means payment is authorized"
      ‚Üí Extract: status_mappings = {"requires_capture": "Authorized"}

      Build comprehensive mappings from all status mentions in tech spec

   **Extraction Strategy**:
   - Read entire tech spec first
   - Identify all 6 flow sections (authorize, capture, void, refund, psync, rsync)
   - For each flow, extract method, path, request format, response structure
   - If uncertain, make intelligent inferences from API documentation patterns
   - Validate extractions make sense (e.g., POST for mutations, GET for queries)

   **Tech spec must be self-contained** - everything needed to make API calls must be extractable!

2. **REQUEST MINIMAL USER CREDENTIALS**:
   After tech spec generation, immediately ask:

   ```
   üîê Tech Spec Credibility Validation

   Connector: {{CONNECTOR_NAME}}
   Test URL (from tech spec): {{EXTRACTED_BASE_URL}}

   To validate the tech spec against the real API, please provide test credentials:

   {
     "api_key": "your_test_key",
     "api_secret": "your_test_secret_if_needed",
     "key1": "additional_key_if_needed"
   }

   Credential requirements (from tech spec):
   - api_key: {{auth.credentials_required.api_key.description}}
   - api_secret: {{auth.credentials_required.api_secret.description}}
   - key1: {{auth.credentials_required.key1.description}}

   IMPORTANT: Use test/sandbox credentials only. Never production credentials!

   These will be stored in testing/tech-spec-validation/{{connector_name}}/credentials.json
   (File is gitignored for security)
   ```

3. **GENERATE CURL TEST SCRIPTS FROM TECH SPEC**:
   For each of 6 flows, extract from tech spec and generate curl script:

   **Extraction Process:**
   ```
   BASE_URL = tech_spec.api_config.test_url
   ENDPOINT = tech_spec.authorize.path
   METHOD = tech_spec.authorize.method
   CONTENT_TYPE = tech_spec.authorize.request.content_type
   AUTH_HEADER_FORMAT = tech_spec.auth.headers[0].format  # "Bearer {api_key}"
   REQUEST_BODY = tech_spec.authorize.request.test_example
   ```

   **Generated Curl:**
   ```bash
   curl -X POST "https://api.stripe.com/v1/payment_intents" \
     -H "Authorization: Bearer ${API_KEY}" \  # Format from spec + user cred
     -H "Content-Type: application/x-www-form-urlencoded" \  # From spec
     -d "amount=1000&currency=usd&payment_method_types[]=card"  # From spec
   ```

   Generate all 6 scripts (01_authorize.sh through 06_rsync.sh)

4. **EXECUTE VALIDATION TESTS SEQUENTIALLY**:
   Run tests in order (some depend on previous results):

   ```bash
   01_authorize.sh  ‚Üí Saves payment_id to state.json
   02_capture.sh    ‚Üí Uses payment_id from state
   03_void.sh       ‚Üí Uses fresh authorization
   04_refund.sh     ‚Üí Uses payment_id from capture
   05_psync.sh      ‚Üí Uses payment_id to check status
   06_rsync.sh      ‚Üí Uses refund_id from refund
   ```

   Each script:
   - Executes curl with params from tech spec
   - Saves response to responses/ directory
   - Validates response against tech spec expectations
   - Updates state.json for dependent tests

5. **ANALYZE RESULTS AGAINST TECH SPEC EXPECTATIONS**:
   For each flow, validate:

   ‚úÖ **HTTP Status Check**:
   - Expected: tech_spec.flow.response.success_status_codes
   - Actual: HTTP response code
   - Match? ‚Üí PASS, else identify issue

   ‚úÖ **Response Structure Check**:
   - Expected fields: tech_spec.flow.response.required_fields
   - Actual: fields in response JSON
   - All present? ‚Üí PASS, else identify missing

   ‚úÖ **Field Name Validation**:
   - ID field at: tech_spec.flow.response.id_field
   - Status field at: tech_spec.flow.response.status_field
   - Found in response? ‚Üí PASS, else tech spec has wrong field names

   ‚úÖ **Status Mapping Validation**:
   - Actual status value in response
   - Exists in tech_spec.flow.response.status_mappings?
   - Mapped? ‚Üí PASS, else add missing mapping

   **Common Issues to Detect:**
   - 404 Not Found ‚Üí Wrong endpoint path in tech spec
   - 401 Unauthorized ‚Üí Wrong auth format in tech spec
   - 400 Bad Request ‚Üí Wrong request body format in tech spec
   - 422 Unprocessable ‚Üí Missing required field in tech spec
   - Missing field ‚Üí Wrong field name in tech spec
   - Unknown status ‚Üí Missing status mapping in tech spec

6. **GENERATE CREDIBILITY REPORT**:
   Create detailed validation report at:
   `testing/tech-spec-validation/{{connector}}/credibility_report.md`

   Include:
   - Summary: X/6 flows passed
   - Detailed results for each flow
   - Identified issues with severity (Critical/High/Medium)
   - Auto-fix recommendations
   - Tech spec credibility score

7. **FEEDBACK LOOP WITH AUTO-FIX** (Max 3 attempts):

   **IF ALL 6 FLOWS PASS:**
   ```
   ‚úÖ Tech Spec Credibility: VALIDATED

   All 6 flows tested successfully against real API.
   Tech spec is accurate and credible.

   Proceeding to implementation planning...
   ```
   ‚Üí Continue to planner_steps.md generation

   **IF ANY FLOW FAILS:**
   ```
   ‚ö†Ô∏è  Tech Spec Validation Failed (Attempt {{N}}/3)

   Issues found:
   - Void endpoint path incorrect (404 error)
   - Missing status mapping: "processing"

   Detailed report: testing/tech-spec-validation/{{connector}}/credibility_report.md

   Choose action:
   [A] Auto-fix - I'll update tech spec and re-validate (Recommended)
   [M] Manual - You update tech spec, I'll re-validate
   [P] Proceed - Continue despite issues (NOT recommended)
   [C] Cancel - Stop for manual review

   Your choice (A/M/P/C):
   ```

   **IF USER CHOOSES [A] AUTO-FIX:**
   - Analyze actual API responses and error messages
   - Update tech spec with corrections:
     * Fix endpoint paths (from 404 error messages)
     * Correct field names (from actual response structure)
     * Add missing status mappings (from actual response values)
     * Update required fields (from 422 errors)
   - Regenerate curl scripts from updated tech spec
   - Re-run all 6 tests
   - Generate new credibility report
   - Show updated results
   - Repeat up to 3 times total

   **IF USER CHOOSES [M] MANUAL:**
   - Wait for user to update tech spec
   - Ask: "Tech spec updated. Ready to re-validate? (Y/N)"
   - If Y: Regenerate curl scripts and re-run tests

   **IF USER CHOOSES [P] PROCEED:**
   - ‚ö†Ô∏è Document all known issues in planner_steps.md
   - Flag connector as "HIGH RISK - Unvalidated Tech Spec"
   - Warn: "Implementation may fail due to incorrect tech spec assumptions"
   - Continue to planning phase

   **IF USER CHOOSES [C] CANCEL:**
   - Stop workflow
   - Provide path to credibility report for review
   - User can manually fix and restart

8. **SUCCESS CRITERIA FOR VALIDATION**:
   Tech spec considered credible ONLY when:
   - ‚úÖ All 6 flows return 2xx HTTP status codes
   - ‚úÖ All required response fields present in actual responses
   - ‚úÖ All actual status values have mappings in tech spec
   - ‚úÖ Authentication format works correctly
   - ‚úÖ Request body formats accepted by API
   - ‚úÖ Endpoint paths exist and respond correctly

   **DO NOT proceed to implementation without validated tech spec!**

9. **SECURITY CONSIDERATIONS**:
   - credentials.json is automatically gitignored
   - Never commit API keys or secrets
   - Use only test/sandbox credentials
   - Responses may contain sensitive data - also gitignored
   - Option to clear credentials after validation

10. **STATE MANAGEMENT**:
    Track validation state for feedback loop:
    ```json
    {
      "connector": "stripe",
      "validation_attempts": 1,
      "max_attempts": 3,
      "current_status": "passed",
      "passed_flows": ["authorize", "capture", "void", "refund", "psync", "rsync"],
      "failed_flows": [],
      "credibility_score": 100,
      "last_validated": "2025-01-15T10:30:00Z"
    }
    ```

REMEMBER: Tech spec validation ensures accurate implementation blueprint. A validated tech spec = trustworthy foundation for code generation!

---

üìä SUCCESS CRITERIA:
- ‚úÖ Tech spec validated via real API testing (NEW - MANDATORY)
- ‚úÖ All supported payment methods implemented
- ‚úÖ All core flows implemented (auth, capture, void, refund, sync)
- ‚úÖ Proper error handling and mapping
- ‚úÖ Code compiles successfully with cargo check
- ‚úÖ UCS patterns followed correctly
- ‚úÖ Webhook implementation (if supported)
- ‚úÖ Production-ready code quality
- ‚úÖ Complete implementation documentation
- **NOTE**: Testing coverage handled separately by QA team

üèõÔ∏è UCS IMPLEMENTATION ARCHITECTURE [VERIFIED FROM CODEBASE]:

CONNECTOR STRUCT PATTERN:
```rust
#[derive(Clone)]
pub struct ConnectorName<T> {
    pub(crate) amount_converter: &'static (dyn AmountConvertor<Output = MinorUnit> + Sync),
    _phantom: std::marker::PhantomData<T>,
}

impl<T> ConnectorName<T> {
    pub const fn new() -> &'static Self {
        &Self {
            amount_converter: &common_utils::types::MinorUnitForConnector,
            _phantom: std::marker::PhantomData,
        }
    }
}
```

TRAIT IMPLEMENTATIONS (Required for each connector):
```rust
impl<T: PaymentMethodDataTypes + Debug + Sync + Send + 'static + Serialize>
    connector_types::PaymentAuthorizeV2<T> for ConnectorName<T> {}

impl<T: PaymentMethodDataTypes + Debug + Sync + Send + 'static + Serialize>
    connector_types::PaymentSyncV2 for ConnectorName<T> {}

impl<T: PaymentMethodDataTypes + Debug + Sync + Send + 'static + Serialize>
    connector_types::RefundV2<T> for ConnectorName<T> {}

impl<T: PaymentMethodDataTypes + Debug + Sync + Send + 'static + Serialize>
    connector_types::PaymentCapture for ConnectorName<T> {}

impl<T: PaymentMethodDataTypes + Debug + Sync + Send + 'static + Serialize>
    connector_types::PaymentVoidV2 for ConnectorName<T> {}

// Add other flows as needed: SetupMandateV2, RepeatPaymentV2, etc.
```

MACROS USAGE (Critical for UCS):
```rust
macros::create_all_prerequisites!(
    connector_name: ConnectorName,
    generic_type: T,
    api: [
        (
            flow: Authorize,
            request_body: ConnectorPaymentRequest<T>,
            response_body: ConnectorPaymentResponse,
            router_data: RouterDataV2<Authorize, PaymentFlowData, PaymentsAuthorizeData<T>, PaymentsResponseData>,
        ),
        (
            flow: Capture,
            request_body: ConnectorCaptureRequest,
            response_body: ConnectorCaptureResponse,
            router_data: RouterDataV2<Capture, PaymentFlowData, PaymentsCaptureData, PaymentsResponseData>,
        ),
        // Add all other flows...
    ]
);
```

MODULE REGISTRATION (Required):
```rust
// In backend/connector-integration/src/connectors.rs
pub mod connector_name;
pub use self::connector_name::ConnectorName;
```

**IMPLEMENTATION FOCUS**:
- **ONLY**: Main connector file and transformers 
- **NOT**: Test files (handled separately by QA team)

‚ö° CONNECTOR TEMPLATE SYSTEM [CRITICAL]:

BOILERPLATE GENERATION:
- ALWAYS use ./connector_template/add_connector.sh to generate initial structure
- Script automatically creates: main file, transformers, protobuf enum, domain types, module registration
- Handles all file modifications and registrations automatically
- Template includes ALL required trait implementations (empty stubs)
- Template provides proper UCS structure with generic types

TEMPLATE OUTPUT:
- Creates: backend/connector-integration/src/connectors/[name].rs
- Creates: backend/connector-integration/src/connectors/[name]/transformers.rs  
- Updates: backend/grpc-api-types/proto/payment.proto (adds enum)
- Updates: backend/domain_types/src/connector_types.rs (adds mapping)
- Updates: backend/connector-integration/src/connectors.rs (adds module)
- Updates: backend/connector-integration/src/types.rs (adds connector)
- Updates: config/development.toml (adds config section)

IMPLEMENTATION FOCUS:
After template generation, implement actual logic in:
1. transformers.rs - Request/response transformations, payment method handling
2. main file - Specific flow implementations (replace empty stubs)
3. Add proper authentication, error handling, URL patterns

üö® CRITICAL REMINDERS:
- ALWAYS use ./connector_template/add_connector.sh for new connectors FIRST
- Template provides correct UCS structure - DON'T recreate manually
- NEVER use traditional Hyperswitch patterns (RouterData, ConnectorIntegration)
- ALWAYS use UCS patterns (RouterDataV2, ConnectorIntegrationV2, domain_types)
- Template creates generic connector struct: pub struct Connector<T: PaymentMethodDataTypes>
- Template includes ALL required trait implementations as empty stubs
- Template handles all module registrations and protobuf updates
- IMPLEMENT actual logic in generated template files (don't start from scratch)
- **EACH FLOW MUST BE COMPLETELY INDEPENDENT** - no shared state or dependencies between flows
- **IMPLEMENT flows separately** - can implement Authorize without Capture, Refund without Authorize, etc.
- **FLOW INDEPENDENCE PRINCIPLE**: Each ConnectorIntegrationV2 implementation stands alone
- **REUSE COMMON CODE**: Use ConnectorCommon methods for headers, auth, errors - DON'T duplicate code
- **NO CODE DUPLICATION**: Authentication, content-type, error handling shared across all flows
- **WHEN STUCK: Reference existing UCS connectors for patterns, DON'T copy code directly**
- **PATTERN LEARNING**: Study existing connector implementations (adyen.rs, razorpayv2.rs, etc.) for architectural patterns
- **VERIFY PATTERNS**: Understand WHY existing connectors use specific patterns before applying
- **AFTER EACH FLOW IMPLEMENTATION: Ask for optional user feedback on code quality**
- **FEEDBACK STORAGE: Store positive/negative feedback in grace-ucs/guides/learnings/learnings.md**
- **REWARD LEARNING: Use accumulated feedback to improve future implementations**
- **AFTER EACH IMPLEMENTATION STEP: Update planner file with [‚úÖ COMPLETED] status and detailed description**
- **PROGRESS TRACKING FORMAT: "- [‚úÖ COMPLETED] Step Name: Implemented [specific_details] in [file_location]"**
- **DO NOT CREATE TEST FILES** - focus only on implementation code (connector + transformers)
- IMPLEMENT ValidationTrait if connector needs special validation (like order creation)
- UPDATE all guide files with learnings during implementation
- CREATE continuation documentation for future development
- MAINTAIN modular structure for easy feature additions
- **VALIDATION**: Ensure code compiles and follows UCS patterns, testing handled separately

üß† PATTERN LEARNING & TROUBLESHOOTING [CRITICAL]:

WHEN IMPLEMENTATION GETS STUCK OR UNCLEAR:
1. **STUDY EXISTING UCS CONNECTORS** for similar patterns:
   - backend/connector-integration/src/connectors/adyen.rs (comprehensive implementation)
   - backend/connector-integration/src/connectors/razorpayv2.rs (modern patterns)
   - backend/connector-integration/src/connectors/checkout.rs (good examples)
   - backend/connector-integration/src/connectors/[others].rs

2. **PATTERN ANALYSIS PROCESS**:
   - Read existing connector's main file for overall structure
   - Study transformers.rs for request/response patterns
   - Understand authentication patterns
   - Analyze error handling approaches
   - Review payment method handling strategies

3. **DON'T COPY - UNDERSTAND**:
   - ‚ùå NEVER directly copy code from existing connectors
   - ‚úÖ UNDERSTAND the pattern and WHY it's used
   - ‚úÖ ADAPT the pattern for your specific connector's API
   - ‚úÖ VERIFY the pattern fits your connector's requirements

4. **SPECIFIC LEARNING AREAS**:
   - **Authentication**: How do other connectors handle auth headers?
   - **Request Building**: How do they structure API requests?
   - **Response Parsing**: How do they handle API responses?
   - **Error Mapping**: How do they map connector errors to UCS errors?
   - **Payment Methods**: How do they handle different payment types?
   - **URL Building**: How do they construct API endpoints?

5. **TROUBLESHOOTING WORKFLOW**:
   ```
   STUCK? ‚Üí Study similar pattern in existing connector ‚Üí Understand WHY ‚Üí Adapt for your connector ‚Üí Test ‚Üí Continue
   ```

6. **REFERENCE CONNECTORS BY USE CASE**:
   - **Complex flows**: Adyen (has most comprehensive implementation)
   - **Modern patterns**: RazorpayV2 (uses latest UCS patterns)
   - **Simple structure**: Checkout (clean, straightforward implementation)
   - **Error handling**: Review multiple connectors for error mapping patterns
   - **Payment methods**: Study how different connectors handle various payment types

REMEMBER: The goal is to LEARN patterns and UNDERSTAND architectural decisions, not to copy code.

üéØ FEEDBACK & REWARD LEARNING SYSTEM [CRITICAL]:

AFTER EACH FLOW IMPLEMENTATION:
1. **ASK FOR OPTIONAL FEEDBACK**: 
   - "Would you like to provide feedback on the [FlowName] implementation? (Optional - you can skip)"
   - "Rate the code quality: Good/Needs Improvement/Bad"
   - "Any specific comments on the implementation approach?"

2. **FEEDBACK COLLECTION PRINCIPLES**:
   - ‚úÖ ALWAYS make feedback optional - never force user to respond
   - ‚úÖ Ask only after completing a significant flow (Authorize, Capture, Refund, etc.)
   - ‚úÖ Keep feedback requests brief and non-intrusive
   - ‚úÖ Accept "skip" or no response as valid
   - ‚ùå DON'T ask for feedback on minor code changes
   - ‚ùå DON'T pressure user to provide feedback

3. **FEEDBACK STORAGE FORMAT**:
   Store ALL feedback in grace-ucs/guides/learnings/learnings.md:
   ```
   ## User Feedback Log
   
   ### [DATE] [CONNECTOR_NAME] - [FLOW_NAME] Implementation
   **Feedback**: [Positive/Negative/Neutral]
   **Rating**: [Good/Needs Improvement/Bad]
   **Comments**: [User's specific comments]
   **Implementation Details**: [What was implemented]
   **Lessons**: [What this teaches us for future implementations]
   ```

4. **REWARD LEARNING APPLICATION**:
   - **Positive Feedback**: Note successful patterns, reuse in future implementations
   - **Negative Feedback**: Identify improvement areas, avoid similar approaches
   - **Neutral/No Feedback**: Continue with current approach
   - **Pattern Recognition**: Identify what users consistently like/dislike

5. **FEEDBACK CATEGORIES TO TRACK**:
   - **Code Structure**: Clean organization, readability
   - **Error Handling**: Comprehensive error mapping and handling
   - **Performance**: Efficient request/response processing
   - **Maintainability**: Easy to understand and modify
   - **UCS Compliance**: Following UCS patterns correctly

6. **LEARNING EVOLUTION**:
   - **Week 1**: Basic pattern following
   - **Week 2**: Incorporating initial feedback
   - **Month 1**: Refined patterns based on user preferences
   - **Month 3**: Highly optimized implementations based on accumulated learning

7. **SAMPLE FEEDBACK REQUEST**:
   ```
   üéØ Optional Feedback Request:
   
   I've completed the Authorize flow implementation for [ConnectorName]. 
   The code includes:
   - Request transformation for card payments
   - Response handling with proper status mapping
   - Error handling for common failure scenarios
   
   Would you like to provide feedback? (Feel free to skip if you prefer)
   - How does the code quality look?
   - Any suggestions for improvement?
   ```

8. **FEEDBACK INTEGRATION WORKFLOW**:
   ```
   Implement Flow ‚Üí Test ‚Üí Ask Optional Feedback ‚Üí Store Response ‚Üí Apply Learning ‚Üí Continue Next Flow
   ```

BENEFITS:
- **Continuous Improvement**: AI gets better with each implementation
- **User-Centric**: Code quality aligns with user preferences
- **Pattern Recognition**: Identifies successful vs unsuccessful approaches
- **Knowledge Base**: Builds repository of what works well in UCS context

[Update all guide files based on learnings during the integration process]
[Create connector-specific folders under connector_integration/ for each implementation]
[Always reference existing UCS connectors for pattern examples - STUDY, don't copy]
[Store user feedback to improve future implementations - OPTIONAL feedback only]